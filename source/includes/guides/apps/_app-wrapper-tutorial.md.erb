### Defining app wrapper templates  

> Example wrapper script that prints out all of Agave's available runtime job macros and runs a user-suppled string defined as the `command` argument in the app description.  

```html
date

echo "Printing Agave job template variables..."

echo 'IPLANT_JOB_NAME="${IPLANT_JOB_NAME}"'
echo 'AGAVE_JOB_NAME="${AGAVE_JOB_NAME}"'
echo 'AGAVE_JOB_ID="${AGAVE_JOB_ID}"'
echo 'AGAVE_JOB_APP_ID="${AGAVE_JOB_APP_ID}"'
echo 'AGAVE_JOB_EXECUTION_SYSTEM="${AGAVE_JOB_EXECUTION_SYSTEM}"'
echo 'AGAVE_JOB_BATCH_QUEUE="${AGAVE_JOB_BATCH_QUEUE}"'
echo 'AGAVE_JOB_SUBMIT_TIME="${AGAVE_JOB_SUBMIT_TIME}"'
echo 'AGAVE_JOB_ARCHIVE_SYSTEM="${AGAVE_JOB_ARCHIVE_SYSTEM}"'
echo 'AGAVE_JOB_ARCHIVE_PATH="${AGAVE_JOB_ARCHIVE_PATH}"'
echo 'AGAVE_JOB_NODE_COUNT="${AGAVE_JOB_NODE_COUNT}"'
echo 'IPLANT_CORES_REQUESTED="${IPLANT_CORES_REQUESTED}"'
echo 'AGAVE_JOB_PROCESSORS_PER_NODE="${AGAVE_JOB_PROCESSORS_PER_NODE}"'
echo 'AGAVE_JOB_MEMORY_PER_NODE="${AGAVE_JOB_MEMORY_PER_NODE}"'
echo 'AGAVE_JOB_ARCHIVE_URL="${AGAVE_JOB_ARCHIVE_URL}"'
echo 'AGAVE_JOB_OWNER="${AGAVE_JOB_OWNER}"'
echo 'AGAVE_JOB_TENANT="${AGAVE_JOB_TENANT}"'
echo 'AGAVE_JOB_ARCHIVE="${AGAVE_JOB_ARCHIVE}"'
echo 'AGAVE_JOB_MAX_RUNTIME="${AGAVE_JOB_MAX_RUNTIME}"'
echo 'AGAVE_JOB_MAX_RUNTIME_MILLISECONDS="${AGAVE_JOB_MAX_RUNTIME_MILLISECONDS}"'
echo "Printing runtime environment..."

env

CALLBACK=$(${command})

${AGAVE_JOB_CALLBACK_NOTIFICATION|CALLBACK}

sleep 3

```  

In order to run your application, you will need to create a wrapper template that calls your executable code. The wrapper template is a simple script that Agave will filter and execute to start your app. The filtering Agave applies to your wrapper script is to inject runtime values from a job request into the script to replace the template variables representing the inputs and parameters of your app.

The order in which wrapper templates are processed in HPC and Condor apps is as follows.

1. `environment` variables injected.
2. `startupScript` run.
3. Scheduler directives prepended to the wrapper template.
4. `additionalDirectives` concatenated after the scheduler directives.
5. Custom `modules` concatenated after the additionalDirectives.
6. `inputs` and `parameters` template variables replaced with values from the job request.
7. Blacklist commands, if present, are disabled in the scripts.
8. Resulting script is written to the remote job execution folder and executed.


The order in which wrapper templates are processed in CLI apps is as follows.

1. Shell environment sourced
2. `environment` variables injected
3. `startupScript` run
4. Custom `modules` prepended to the top of the wrapper
5. `inputs` and `parameters` template variables replaced with values from the  job request
6. Blacklist commands, if present, are disabled in the scripts.
7. Resulting script is forked into the background immediately.

#### Environment  

Comes from the system definition. Handle in your script if you cannot change the system definition to suite your needs. Ship whatever you need with your app's assets.

#### Using modules in wrapper templates  

See more about <a href="http://modules.sourceforge.net/" title="The Environment Modules Project" target="_blank">Modules</a> and <a href="https://github.com/TACC/Lmod" title="Lmod: An Environment Module System based on Lua" target="_blank">Lmod</a>. Can be used to customize your environment, locate your application, and improve portability between systems. Agave does not install or manage the module installation on a particular system, however it does know how to interact with it. Specifying the modules needed to run your app either in your wrapper template or in your system definition can greatly help you during the development process.

#### Available wrapper template runtime macros

Agave provides information about the job, system, and user as predefined macros you can use in your wrapper templates. The full list of  runtime job macros are give in the following table.

<%= partial "includes/tables/64" %>


#### Handling app inputs  

Agave will stage the files and folders you specify as inputs to your app. These will be available in the top level of your job directory at runtime. Additionally, the names of each of the inputs will be injected into your wrapper template for you to use in your application logic. Please be aware that Agave will not attempt to resolve namespace conflicts between your app inputs. That means that if a job specifies two inputs with the same name, one will overwrite the other during the input staging phase of the job and, though the variable names will be correctly injected to the wrapper script, your job will most likely fail due to missing data.

#### Handling app parameters

If you refer back to the app definition we used in the App Management Tutorial, you will see there are multiple inputs and parameters defined for that app. Each input and parameter object had an `id` attribute. That `id` value is the attribute name you use to associate runtime values with app inputs and parameters. When a job is submitted to Agave, prior to physically running the wrapper template, all instances of that `id` are replaced with the actual value from the job request. The example below shows our app description, a job request, and the resulting wrapper template at run time.

#### Variable type casting 

During the jobs submission process, Agave will store your inputs and parameters as serialized JSON. At the point that variable injection occurs, Agave will replace all occurrences of your input and parameter with their value provided in the job request. In order for Agave to properly identify your input and parameter ids, wrap them in brackets and prepend a dollar sign. For example, if you have a parameter with id `param1`, you would include it in your wrapper script as `${param1}`. Case sensitivity is honored at all times.

#### Handling boolean values  

Boolean values are passed in as truthy values. true = 1, false is empty. 

#### Using flag parameters  

If your parameter was of type "flag", Agave will replace all occurences of the template variable with the value you provided for the `argument` field.

<aside class="info">The cardinality and validation fields in an app's input and parameter definitions are not used in resolving wrapper template variables. The constraints imposed by each of these fields are already satisfied before the job is accepted. In your wrapper script, you can safely operate under the assumption that your inputs and parameters have been validated to the degree specified in your app definition.</aside>
